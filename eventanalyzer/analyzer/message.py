import instructor
from openai import OpenAI
from jinja2 import Environment, FileSystemLoader
from pathlib import Path
from pydantic import BaseModel, Field
from datetime import datetime
import re
import logging

from ..config import config
from .schemas import NewsAnalysis, InitialNews

logger = logging.getLogger(__name__)


class TelegramMessage(BaseModel):
    text: str = Field(description="Ready-to-send Telegram message text")


class MessageGenerationService:
    def __init__(self):
        self.client = instructor.from_openai(
            OpenAI(
                api_key=config.openai_api_key,
                base_url=config.openai_base_url
            ),
            mode=instructor.Mode.JSON
        )
        
        template_dir = Path(__file__).parent / "prompts"
        self.jinja_env = Environment(loader=FileSystemLoader(template_dir))
    
    def _clean_formatting_placeholders(self, text: str) -> str:
        """Clean up any leftover formatting placeholders that might have been generated by AI."""
        # Replace any leftover formatting placeholders with proper markdown
        text = text.replace('||BOLD||', '*')
        text = text.replace('||ITALIC||', '_')  
        text = text.replace('||CODE||', '`')
        return text
    
    def _validate_markdown(self, text: str) -> str:
        """Validate and fix common Markdown formatting issues for Telegram."""
        # First clean up any formatting placeholders
        text = self._clean_formatting_placeholders(text)
        
        # Process the text character by character to handle nested formatting correctly
        result = []
        i = 0
        
        # Track open formatting tags
        asterisk_stack = []  # Track positions of unmatched asterisks
        underscore_stack = []  # Track positions of unmatched underscores
        backtick_stack = []  # Track positions of unmatched backticks
        bracket_stack = []  # Track positions of unmatched brackets
        
        while i < len(text):
            char = text[i]
            
            if char == '*':
                if asterisk_stack:
                    asterisk_stack.pop()  # Close the formatting
                else:
                    asterisk_stack.append(len(result))  # Open new formatting
                result.append(char)
            elif char == '_':
                if underscore_stack:
                    underscore_stack.pop()  # Close the formatting
                else:
                    underscore_stack.append(len(result))  # Open new formatting
                result.append(char)
            elif char == '`':
                if backtick_stack:
                    backtick_stack.pop()  # Close the formatting
                else:
                    backtick_stack.append(len(result))  # Open new formatting
                result.append(char)
            elif char == '[':
                bracket_stack.append(len(result))
                result.append(char)
            elif char == ']':
                if bracket_stack:
                    bracket_stack.pop()
                result.append(char)
            else:
                result.append(char)
            
            i += 1
        
        # Close any remaining open formatting tags
        text = ''.join(result)
        
        # Add closing tags for unmatched formatting
        if asterisk_stack:
            text += '*' * len(asterisk_stack)
        if underscore_stack:
            text += '_' * len(underscore_stack)
        if backtick_stack:
            text += '`' * len(backtick_stack)
        if bracket_stack:
            text += ']' * len(bracket_stack)
        
        # Fix unmatched parentheses for links
        open_parens = text.count('](')
        # Count complete markdown links
        link_pattern = r'\]\([^)]*\)'
        actual_links = len(re.findall(link_pattern, text))
        
        # If we have ]( but not enough closing ), add them
        if open_parens > actual_links:
            text += ')' * (open_parens - actual_links)
        
        return text
    
    def _smart_truncate(self, text: str, max_length: int = 3800) -> str:
        """Intelligently truncate text while preserving Markdown formatting."""
        if len(text) <= max_length:
            return text
        
        # Try to truncate at a sentence boundary
        truncate_at = max_length - 10  # Leave room for "..."
        
        # Look for sentence endings near the truncation point
        sentence_endings = ['. ', '! ', '? ', '\n\n']
        best_cut = truncate_at
        
        for ending in sentence_endings:
            pos = text.rfind(ending, 0, truncate_at)
            if pos > truncate_at - 200:  # Don't go too far back
                best_cut = pos + len(ending)
                break
        
        truncated = text[:best_cut].rstrip()
        
        # Ensure Markdown formatting is balanced after truncation
        truncated = self._validate_markdown(truncated)
        
        return truncated + "..."
    
    async def generate_telegram_message(self, analysis: NewsAnalysis, initial_news: InitialNews, custom_instruction: str = None) -> str:
        """Generate user-friendly Telegram message from analysis results."""
        template = self.jinja_env.get_template("telegram_message.j2")
        prompt = template.render(
            analysis=analysis,
            initial_news=initial_news,
            custom_instruction=custom_instruction or "Please provide a neutral and objective analysis."
        )
        
        logger.info(f"Generating message for analysis with score {analysis.credibility_score}/10")
        
        response = self.client.chat.completions.create(
            model=config.openai_model,
            response_model=TelegramMessage,
            messages=[
                {"role": "system", "content": f"You are a professional news analyst creating clear, engaging messages for Telegram users. Today is {datetime.now().strftime('%Y-%m-%d')}. Your answer MUST be no more than 3800 characters to ensure it fits within Telegram's limits. Use proper Markdown formatting."},
                {"role": "user", "content": prompt}
            ],
            temperature=0.1,
        )
        
        # Validate and fix Markdown formatting
        result = self._validate_markdown(response.text)
        
        # Final length check and truncation if needed
        if len(result) > 3800:
            logger.warning(f"Generated message too long ({len(result)} chars), truncating to 3790")
            result = self._smart_truncate(result)
        
        logger.info(f"Generated message: {len(result)} characters")
        
        return result 